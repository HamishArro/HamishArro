{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport THREE from \"./Three\";\nexport function alignMesh(mesh) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 0.5,\n    y: 0.5,\n    z: 0.5\n  };\n  var nAxis = axis || {};\n  var box = new THREE.Box3().setFromObject(mesh);\n  var size = new THREE.Vector3();\n  box.getSize(size);\n  var min = {\n    x: -box.min.x,\n    y: -box.min.y,\n    z: -box.min.z\n  };\n\n  for (var _i = 0, _Object$keys = Object.keys(nAxis); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var scale = nAxis[key];\n    mesh.position[key] = min[key] - size[key] + size[key] * scale;\n  }\n}\nexport function scaleLongestSideToSize(mesh, size) {\n  var sizedVector = new THREE.Vector3();\n  new THREE.Box3().setFromObject(mesh).getSize(sizedVector);\n  var width = sizedVector.x,\n      height = sizedVector.y,\n      depth = sizedVector.z;\n  var longest = Math.max(width, Math.max(height, depth));\n  var scale = size / longest;\n  mesh.scale.set(scale, scale, scale);\n}\nexport function computeMeshNormals(mesh) {\n  mesh.traverse(function _callee(child) {\n    var temp;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (child instanceof THREE.Mesh) {\n              temp = toGeometry(child.geometry);\n              temp.mergeVertices();\n              temp.computeVertexNormals();\n              temp.computeFaceNormals();\n              child.geometry = new THREE.BufferGeometry().fromGeometry(temp);\n            }\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  });\n}\nexport function toBufferGeometry(geometry) {\n  if (geometry instanceof THREE.BufferGeometry) {\n    return geometry;\n  }\n\n  var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  return bufferGeometry;\n}\nexport function toGeometry(geometry) {\n  if (geometry instanceof THREE.Geometry) {\n    return geometry;\n  }\n\n  return new THREE.Geometry().fromBufferGeometry(geometry);\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import THREE from './Three';\n\nexport function alignMesh(mesh: THREE.Mesh, axis = { x: 0.5, y: 0.5, z: 0.5 }) {\n  const nAxis = axis || {};\n  const box = new THREE.Box3().setFromObject(mesh);\n\n  let size = new THREE.Vector3();\n  box.getSize(size);\n  const min = { x: -box.min.x, y: -box.min.y, z: -box.min.z };\n\n  for (const key of Object.keys(nAxis)) {\n    const scale = nAxis[key];\n    mesh.position[key] = min[key] - size[key] + size[key] * scale;\n  }\n}\n\nexport function scaleLongestSideToSize(mesh: THREE.Mesh, size: number) {\n  let sizedVector = new THREE.Vector3();\n  new THREE.Box3().setFromObject(mesh).getSize(sizedVector);\n\n  const { x: width, y: height, z: depth } = sizedVector;\n\n  const longest = Math.max(width, Math.max(height, depth));\n  const scale = size / longest;\n  mesh.scale.set(scale, scale, scale);\n}\n\n/** Used for smoothing imported meshes */\nexport function computeMeshNormals(mesh: THREE.Mesh) {\n  mesh.traverse(async (child: any) => {\n    if (child instanceof THREE.Mesh) {\n      /// Smooth geometry\n      const temp = toGeometry(child.geometry);\n      temp.mergeVertices();\n      temp.computeVertexNormals();\n      temp.computeFaceNormals();\n\n      child.geometry = new THREE.BufferGeometry().fromGeometry(temp);\n    }\n  });\n}\n\nexport function toBufferGeometry(\n  geometry: THREE.Geometry | THREE.BufferGeometry\n): THREE.BufferGeometry {\n  if (geometry instanceof THREE.BufferGeometry) {\n    return geometry;\n  }\n  const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  return bufferGeometry;\n}\n\nexport function toGeometry(\n  geometry: THREE.Geometry | THREE.BufferGeometry\n): THREE.Geometry {\n  if (geometry instanceof THREE.Geometry) {\n    return geometry;\n  }\n  return new THREE.Geometry().fromBufferGeometry(geometry);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}